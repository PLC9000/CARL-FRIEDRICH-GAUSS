"""Marketplace: comparación de operaciones reales entre recetas."""

import logging
from typing import List

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.database import get_db
from app.config import get_settings
from app.models import User, Recipe, Recommendation, Approval, ApprovalStatus, TradeExecution
from app.auth.dependencies import get_current_user
from app.schemas import CompareRequest, RecipeRealStatsOut, RecipeTradeOut

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/marketplace", tags=["Marketplace"])


def _get_recipe_stats(
    recipe_id: int, user_id: int, db: Session, fee_pct: float,
) -> RecipeRealStatsOut | None:
    """Compute real trade statistics for a single recipe."""
    recipe = db.query(Recipe).filter(Recipe.id == recipe_id, Recipe.user_id == user_id).first()
    if recipe is None:
        return None

    # Find all recommendations generated by this recipe
    # recipe_id is stored inside Recommendation.metrics JSON
    recs = (
        db.query(Recommendation)
        .filter(Recommendation.user_id == user_id)
        .all()
    )
    rec_ids = [r.id for r in recs if (r.metrics or {}).get("recipe_id") == recipe_id]

    if not rec_ids:
        return RecipeRealStatsOut(
            recipe_id=recipe.id, recipe_name=recipe.name,
            symbol=recipe.symbol, interval=recipe.interval,
            strategies=recipe.strategies or [], mode=recipe.mode,
            total_trades=0, wins=0, losses=0, win_rate=0.0,
            net_pnl=0.0, gross_pnl=0.0, avg_win=0.0, avg_loss=0.0,
            profit_factor=None, best_trade=0.0, worst_trade=0.0, trades=[],
        )

    # Get filled trade executions via approval chain
    trades = (
        db.query(TradeExecution)
        .join(Approval, TradeExecution.approval_id == Approval.id)
        .filter(
            Approval.recommendation_id.in_(rec_ids),
            TradeExecution.status == "filled",
        )
        .order_by(TradeExecution.executed_at.desc())
        .all()
    )

    # Filter to closed trades and compute P&L
    closed_trades: list[RecipeTradeOut] = []
    win_pnls: list[float] = []
    loss_pnls: list[float] = []
    all_gross: list[float] = []
    all_net: list[float] = []

    for t in trades:
        result = t.result or {}
        if result.get("oco_status") != "ALL_DONE":
            continue
        exit_time = result.get("exit_time")
        if not exit_time:
            continue

        # Compute P&L
        exit_px = result.get("exit_price", 0)
        entry_px = t.price or 0
        if entry_px <= 0 or exit_px <= 0:
            continue

        if t.side == "BUY":
            pnl_pct = (exit_px - entry_px) / entry_px * 100
        else:
            pnl_pct = (entry_px - exit_px) / entry_px * 100

        qty = t.quantity or 0
        pnl_abs = round(pnl_pct / 100 * entry_px * qty, 4)
        net_pnl_pct = pnl_pct - fee_pct * 2
        net_pnl_abs = round(net_pnl_pct / 100 * entry_px * qty, 4)
        exit_type = result.get("exit_type", "UNKNOWN")

        closed_trades.append(RecipeTradeOut(
            trade_id=t.id,
            symbol=t.symbol,
            side=t.side,
            entry_price=entry_px,
            exit_price=exit_px,
            quantity=qty if qty > 0 else None,
            exit_type=exit_type,
            pnl_pct=round(pnl_pct, 4),
            net_pnl_abs=net_pnl_abs,
            executed_at=str(t.executed_at or ""),
            exit_time=exit_time,
        ))

        all_gross.append(pnl_abs)
        all_net.append(net_pnl_abs)
        if exit_type == "TP":
            win_pnls.append(net_pnl_abs)
        elif exit_type == "SL":
            loss_pnls.append(net_pnl_abs)

    total = len(closed_trades)
    wins = len(win_pnls)
    losses = len(loss_pnls)
    gross_pnl = round(sum(all_gross), 2) if all_gross else 0.0
    net_pnl = round(sum(all_net), 2) if all_net else 0.0
    avg_win = round(sum(win_pnls) / wins, 2) if wins else 0.0
    avg_loss = round(sum(loss_pnls) / losses, 2) if losses else 0.0
    gross_wins = sum(g for g in all_gross if g > 0)
    gross_losses = abs(sum(g for g in all_gross if g < 0))
    pf = round(gross_wins / gross_losses, 2) if gross_losses > 0 else None
    best = round(max(all_net), 2) if all_net else 0.0
    worst = round(min(all_net), 2) if all_net else 0.0

    return RecipeRealStatsOut(
        recipe_id=recipe.id, recipe_name=recipe.name,
        symbol=recipe.symbol, interval=recipe.interval,
        strategies=recipe.strategies or [], mode=recipe.mode,
        total_trades=total, wins=wins, losses=losses,
        win_rate=round(wins / total * 100, 1) if total > 0 else 0.0,
        net_pnl=net_pnl, gross_pnl=gross_pnl,
        avg_win=avg_win, avg_loss=avg_loss,
        profit_factor=pf, best_trade=best, worst_trade=worst,
        trades=closed_trades,
    )


@router.post(
    "/compare",
    response_model=List[RecipeRealStatsOut],
    summary="Comparar operaciones reales de recetas seleccionadas",
)
def compare_recipes(
    body: CompareRequest,
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Devuelve estadísticas de operaciones reales cerradas para las recetas seleccionadas."""
    settings = get_settings()
    fee_pct = settings.commission_pct

    results = []
    for rid in body.recipe_ids:
        stats = _get_recipe_stats(rid, user.id, db, fee_pct)
        if stats is not None:
            results.append(stats)

    # Sort by net P&L descending
    results.sort(key=lambda r: r.net_pnl, reverse=True)
    return results
